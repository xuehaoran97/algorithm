

1([1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)).给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以最小化 。返回分配方案中尽可能最小的最大工作时间 。

思路：回溯+剪枝 优先分配给没有任务的工人

回溯 就是讲每个任务尝试分配给所有的工人

```java
class Solution {


    int ans = Integer.MAX_VALUE;
    public int minimumTimeRequired(int[] jobs, int k) {
        int[] sum = new int[k];
        dfs(sum, jobs, 0, k, 0,0);
        return ans;
       

    }

    void dfs(int[] sum, int[] jobs, int max, int k, int u, int worker_id){
        if(max>=ans){
            return;
        }

        if(u == jobs.length){
           
            ans = max;
            return;
        }
        if(worker_id<k){
            sum[worker_id] = jobs[u];
            dfs(sum,jobs,Math.max(max,sum[worker_id]),k,u+1,worker_id+1);
            sum[worker_id] = 0;
        }
        for(int i =0;i<worker_id;i++){
            sum[i] += jobs[u];
            dfs(sum,jobs,Math.max(max,sum[i]),k,u+1,worker_id);
            sum[i] -= jobs[u];
        }


    }
}
```



### 01背包问题

#### 1.最简单的

有N件物品和一个容量是V的背包。每件物品有且只有一件。

第 i件物品的体积是 v[i]，价值是w[i] 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大

#### 原始想法

```matlab
dp[i][c] = dp[i-1][c] + dp[i-1][c-v[i]] + w[i]
```

```
```









#### 剑指Offer

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列

<font color="red">思路</font>

一个栈模拟入栈操作，每次入栈后。立即查找出栈数组，是否满足出栈条件，满足立即弹出。

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
       int n = pushed.length;
        int index = 0;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            stack.add(pushed[i]);
            while(!stack.isEmpty() && stack.peek() == popped[index]){
                stack.pop();
                index++;
            }

        }

        return stack.isEmpty();
    }
}
```





