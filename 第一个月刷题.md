

1([1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)).给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以最小化 。返回分配方案中尽可能最小的最大工作时间 。

思路：回溯+剪枝 优先分配给没有任务的工人

```java
if(worker_id<k){
  sum[worker_id] = jobs[u];
  dfs(sum,jobs,Math.max(max,sum[worker_id]),k,u+1,worker_id+1);
  sum[worker_id] = 0;
}
```



回溯 就是讲每个任务尝试分配给所有的工人

```java
class Solution {


    int ans = Integer.MAX_VALUE;
    public int minimumTimeRequired(int[] jobs, int k) {
        int[] sum = new int[k];
        dfs(sum, jobs, 0, k, 0,0);
        return ans;
       

    }

    void dfs(int[] sum, int[] jobs, int max, int k, int u, int worker_id){
        if(max>=ans){
            return;
        }
        if(u == jobs.length){    
            ans = max;
            return;
        }
        if(worker_id<k){
            sum[worker_id] = jobs[u];
            dfs(sum,jobs,Math.max(max,sum[worker_id]),k,u+1,worker_id+1);
            sum[worker_id] = 0;
        }
        for(int i =0;i<worker_id;i++){
            sum[i] += jobs[u];
            dfs(sum,jobs,Math.max(max,sum[i]),k,u+1,worker_id);
            sum[i] -= jobs[u];
        }


    }
}
```



### 01背包问题

#### 1.最简单的

有N件物品和一个容量是V的背包。每件物品有且只有一件。

第 i件物品的体积是 v[i]，价值是w[i] 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大

#### 原始想法

```matlab
dp[i][c] = dp[i-1][c] + dp[i-1][c-v[i]] + w[i]
```

```
```









#### 剑指Offer

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列

<font color="red">思路</font>

一个栈模拟入栈操作，每次入栈后。立即查找出栈数组，是否满足出栈条件，满足立即弹出。

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
       int n = pushed.length;
        int index = 0;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            stack.add(pushed[i]);
            while(!stack.isEmpty() && stack.peek() == popped[index]){
                stack.pop();
                index++;
            }

        }

        return stack.isEmpty();
    }
}
```



#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

<font color="red">思路</font>

序列化与反序列化都需要使用队列来完成，，序列化时。当一个node需要出队列时，判断这个队列是否为null。 如果是null的话，只需在结果中加入null即可。 反序列化时，先将根结点放入队列中，开始出队。节点为非null时才能入队。

```java
import apple.laf.JRSUIUtils;

import java.util.LinkedList;
import java.util.Queue;

public class 剑指Offer37 {

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node5 = new TreeNode(5);
        root.left = node2;
        root.right = node3;
        node3.left = node4;
        node3.right = node5;
        String serialize = serialize(root);
        System.out.println(serialize);
        TreeNode deserialize = deserialize(serialize);
        System.out.println(root.right.val);


    }

    // Encodes a tree to a single string.
    public static String serialize(TreeNode root) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node!=null){
                stringBuilder.append(node.val+",");
                queue.add(node.left);
                queue.add(node.right);
            }else{
                stringBuilder.append("null,");
            }
        }
        stringBuilder.deleteCharAt(stringBuilder.length()-1);
        stringBuilder.append("]");
        return stringBuilder.toString();


    }

    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String data) {
        if(data .equals("[]")){
            return null;
        }

        String[] vals = data.substring(1, data.length() - 1).split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        queue.add(root);
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!vals[i].equals("null")){
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            if(!vals[i].equals("null")){
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;
    }
}

class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
}




```







<font color="red">思路</font>：每一都需要遍历候选的数组，选过的会有一个标记数组，标记其已经被选择过了。 然后对于重复的数组，每次就只选择重复的第一个。  有一个很巧妙的设计。

```java
if (vis[j] || (j > 0 && !vis[j - 1] && arr[j - 1] == arr[j])) {
      continue;
 }
```

vis就是访问数组，访问过的会被设置成true。 回溯后呢，会被设置成false。 当vis[j]为false，说明当前元素没有被访问过，而vis[j-1]为false，分为两种情况。第一种是回溯返回的，第二种是重复被跳过的。无论是哪种方式，如果当前元素与前一个元素相同，说明重复了，应该跳过。(此处需要注意数组越界)

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class 剑指Offer38 {
    static List<String> res;
    static boolean[] visited;

    public static String[] permutation(String s) {
        res = new LinkedList<>();
        visited = new boolean[s.length()];
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        StringBuilder sb = new StringBuilder();
        dfs(chars,0,chars.length,sb);
        String[] resc = new String[res.size()];
        int index = 0;
        for(String string:res){
            resc[index] = string;
            index++;
        }
        return resc;

    }


    public static void dfs(char[] chars, int i, int n,StringBuilder sb){
        if(i == n){
            res.add(sb.toString());
            return;
        }
        for (int j = 0; j < n; j++) {
            if(visited[j] || j>0&&!visited[j-1] && chars[j] == chars[j-1]){
                continue;
            }

            visited[j] = true;
            sb.append(chars[j]);
            dfs(chars,i+1,n,sb);
            sb.deleteCharAt(sb.length()-1);
            visited[j] = false;
        }
    }

    public static void main(String[] args) {
        String[] aabs = permutation("aab");
        for(String s:aabs){
            System.out.println(s);
        }
    }
}

```

#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)<font color="red">待做</font>

#### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)(太简单，不看)

<font color="red">思路</font>：排序，中间的就是

```java
class Solution {
    public int majorityElement(int[] nums) {

        Arrays.sort(nums);
        return nums[nums.length/2];

    }
}
```

#### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

<font color="red">思路</font>：队列

```java
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class 剑指Offer32 {
    public static int[] levelOrder(TreeNode root) {
        if(root == null){
            return new int[]{};
        }
        List<Integer> list = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node!=null){
                queue.add(node.left);
                queue.add(node.right);
                list.add(node.val);
            }
        }
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);

        }
        return res;
    }



    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        TreeNode node5 = new TreeNode(5);
        root.left = node2;
        root.right = node3;
        node3.left = node4;
        node3.right = node5;
        int[] ints = levelOrder(root);
        for(int n:ints){
            System.out.println(n);
        }
    }

}

```

