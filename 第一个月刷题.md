

1([1723. 完成所有工作的最短时间](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)).给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以最小化 。返回分配方案中尽可能最小的最大工作时间 。

思路：回溯+剪枝 优先分配给没有任务的工人

回溯 就是讲每个任务尝试分配给所有的工人

```java
class Solution {


    int ans = Integer.MAX_VALUE;
    public int minimumTimeRequired(int[] jobs, int k) {
        int[] sum = new int[k];
        dfs(sum, jobs, 0, k, 0,0);
        return ans;
       

    }

    void dfs(int[] sum, int[] jobs, int max, int k, int u, int worker_id){
        if(max>=ans){
            return;
        }

        if(u == jobs.length){
           
            ans = max;
            return;
        }
        if(worker_id<k){
            sum[worker_id] = jobs[u];
            dfs(sum,jobs,Math.max(max,sum[worker_id]),k,u+1,worker_id+1);
            sum[worker_id] = 0;
        }
        for(int i =0;i<worker_id;i++){
            sum[i] += jobs[u];
            dfs(sum,jobs,Math.max(max,sum[i]),k,u+1,worker_id);
            sum[i] -= jobs[u];
        }


    }
}
```



